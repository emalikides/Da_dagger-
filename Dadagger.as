package {	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.display.StageDisplayState;	import flash.display.Sprite;	import Player.*;	import Enemy.*;	import Xtra.*;	import Weapon.*;	import Powerup.*;	import graphx.*;		//problems:	//pausing:-how listen for events? p would be nice, but all keyboard events are taken by the user.		public class Dadagger extends MovieClip {				//Testing sprite **DELETE me later		var mySprite:Sprite = new Sprite();		var S2:Sprite = new Sprite();				public var user:Player;		//array of enemies, (allows more than one enemy to be created).		public var enemies:Array;		public var gravity:Number=1;		//gain between collisions of players.		public var cg:Number=0.2;				//public var enemyno:int=0;				//Array storing all updgrades in the game.		public var powerups:Array;		//Array storing all weapons in the game.		public var weapons:Array;		//Array storing all Xtras in the game.		public var xtras:Array;		/*Array that stores whether a particular enemy has been hit by the user during an attack so		it may only decrement one amount of health*/		public var enemyhit:Array;				/*Array that stores which enemies have hit the user, updated at the end of each enemie's attack */		public var userhit:Array;		//variable that says whether a collision has been detected, for use in		//optimizing resetting of enemyhit.		public var collisiondtctd:Boolean=false;		//iterator		public var f:int=Math.round(Math.random()*50);				public function Dadagger() {			trace("under developement");			//set stage properties to enable user keyboard input.		}				//function to initialize gameplay		public function setup() {			//add the test sprite -Delete later!			addChild(mySprite);			addChild(S2);						enemyhit=new Array();			userhit=new Array();			//add user (creation done in choose player frame)			user = new Oocha(50,stage.stageWidth, stage.stageHeight, new Point(400,200));			addChild(user);			user.setBox(new Point(user.getBounds(this).width,user.getBounds(this).height));						//create/add enemy.			enemies=new Array();			enemies.push(new Jelly_Boss(3,stage.stageWidth,stage.stageHeight,new Point(200,200)));						var i:int;			for (i=0; i<enemies.length; i++) {				//set the initial bounding box of each enemy				enemies[i].setBox(new Point(enemies[i].getBounds(this).width,enemies[i].getBounds(this).height));				//add all the enemies to the stage				addChild(enemies[i]);				enemyhit.push(false);				userhit.push(false);			}						weapons = new Array();									//set up the IO			stage.addEventListener(Event.ENTER_FRAME, everyFrame);			stage.addEventListener(KeyboardEvent.KEY_DOWN, user.playerControl);			stage.addEventListener(KeyboardEvent.KEY_UP, user.onKeyRelease);						stage.addEventListener(KeyboardEvent.KEY_DOWN, pauseGame);								}				//The GAME LOOP Note: this is conveniently configured so as to animate according to the frame rate,		//This allows for easy pausing etc.		public function everyFrame(e:Event) {			//check if an attack has finished and reset the collision detection boleans.			//if there has been no detected enemy hit, skip this for faster runtime			//make sure this is BEFORE moveme, or the canattack won't be set to true, and the			//program will think the attack has never finished.			if ((user.canattack)&&collisiondtctd) {				var i:int;				for (i=0;i<enemyhit.length; i++) enemyhit[i]=false;				collisiondtctd=false;			}						//draw the offset boxes of the stuff on the stage.			mySprite.graphics.clear();			graphx.Graphx.drawRectangle(new Rectangle(user.offsetbox.x,user.offsetbox.y,user.offsetbox.width,user.offsetbox.height),mySprite);			for(i=0; i<enemies.length;i++) {			graphx.Graphx.drawRectangle(new Rectangle(enemies[i].offsetbox.x,enemies[i].offsetbox.y,enemies[i].offsetbox.width,enemies[i].offsetbox.height),mySprite);			}									//move the enemy			enemies[0].enemyControl(f);									f = (f>10000)?0:f+1;					//do physics			//update velocities			user.updatev(gravity);									for(i=0; i<enemies.length;i++) {				enemies[i].updatev(gravity);			}									//check for collisions-do this after updating the velocities because the collision testing			//between players depends on future velocities.			collisions();									//update position			moveAll();									//do the physics of the weapons (move them).			//for each (var w:Weapon in weapons) w.x += w.throwvel;						//cleanup any dead enemies			cleanUp();									//check if the user is still alive, or if the match has been won.			//if (!user.alive) tearDown();			if (beatAll()) goNext();											}				//function that determines whether all the enemies are dead.		public function beatAll():Boolean {			var b:Boolean=false;			b = enemies.length==0;			//since we remove each enemy as it is added, we have won when they are all gone			//this is a matter of choice...			/*Clause necessary, otherwise b wil be undefined if enemies empty.			if (enemies.length != 0) {				for each (var e:Enemy in enemies) b = (b&&!e.alive);			}*/			return b;		}				//function to clean up dead enemies and expired extras at the end of each frame.		public function cleanUp() {			//clean up dead enemies.			var i:int;			for (i=0;i<enemyhit.length; i++) {				if (!enemies[i].alive) {					trace("an enemy has died");					this.removeChild(enemies[i]);					enemies.splice(i,1);					enemyhit.splice(i,1);					userhit.splice(i,1);					}			}			//clean up expired extras.						//clean up expired powerups.		}				//function that cleans everything up, and goes to the game over screen.		public function tearDown() {			if (user.lives == 0) {				//remove event listeners				stage.removeEventListener(Event.ENTER_FRAME, everyFrame);				stage.removeEventListener(KeyboardEvent.KEY_DOWN, user.playerControl);				stage.removeEventListener(KeyboardEvent.KEY_UP, user.onKeyRelease);				stage.removeEventListener(KeyboardEvent.KEY_DOWN, pauseGame);				//remove user				removeChild(user);								//remove all upgrades, weapons and xtras												//goto the game over screen				gotoAndStop(5);			} else {				user.lives--;				//stop the enemy								//remove all Xtras								//remove  all upgrades								//re-load user and enemy with full health, 								//display message								//start enemy and user.			}		}				//function that removes relevant objects, and reloads the game to the next level.		public function goNext() {			trace("You have beaten everyone! \n the next level is yet to be coded.");			//remove event listeners				stage.removeEventListener(Event.ENTER_FRAME, everyFrame);				stage.removeEventListener(KeyboardEvent.KEY_DOWN, user.playerControl);				stage.removeEventListener(KeyboardEvent.KEY_UP, user.onKeyRelease);				stage.removeEventListener(KeyboardEvent.KEY_DOWN, pauseGame);				//remove user				removeChild(user);				setup();				//remove stuff				//add xtras (eg signs..)				//update user health (not lives, and position).				//add new enemy				}				//function that implements the physics of the objects on the screen.		public function moveAll() {			var i:int;			//move the user			user.x += user.vel[0];			user.y += user.vel[1];			//reset the position of the bounding box			user.resetBox();						//move the enemies			for(i=0;i<enemies.length;i++) {				enemies[i].x += enemies[i].vel[0];				enemies[i].y += enemies[i].vel[1];				enemies[i].resetBox();			}									/*			//move the weapons			for (i=0; i<weapons.length; i++) {				weapons[i].x += weapons[i].vel[0];				weapons[i].y += weapons[i].vel[1];			}						//move the xtras			for (i=0; i<xtras.length; i++) {				xtras[i].x += xtras[i].vel[0];				xtras[i].y += xtras[i].vel[1];			}		*/				}						//function that checks for collisions between all relevant objects in the game		public function collisions() {						var n:int;			//check if the user has hit the enemies drawing			for each (var e:Enemy in enemies) {								if (user.hitTestPoint(e.hand.x+e.x,e.hand.y+e.y,true)					//user.hitTestPoint(e.foot.x+e.x,e.foot.y+e.y,true)											&&(!e.canattack)&&(!userhit[n])) {					user.sicken(e.power);					userhit[n]=true;				}								//if the user has attacked and any of the significant points overlap the enemy, 				//sicken the enemy				//we must rescale the x coordinates, or the coordinate checked will be the reflection 				//of the coordinate we want.				if ((e.hitTestPoint(user.scaleX*user.hand.x+user.x,user.hand.y+user.y,true)||					 e.hitTestPoint(user.scaleX*user.head.x+user.x,user.head.y+user.y,true)||					 e.hitTestPoint(user.scaleX*user.foot.x+user.x,user.foot.y+user.y,true))&&					(!user.canattack)&&(!enemyhit[n]))				{					trace("collision detected",e.x,e.y,user.hand.x,user.hand.y,"\n",user.x+user.hand.x,user.y+user.hand.y);							S2.graphics.clear();					S2.graphics.beginFill(0x000000); 					S2.graphics.drawCircle(user.x+user.hand.x,user.y+user.hand.y, 3);										e.sicken(user.attackeffect);					enemyhit[n]=true;					collisiondtctd=true;				}												//check if the enemy has finished an attack and reset the booleans.				if (e.canattack) {userhit[n]=true};								//check if any weapons have collided with the enemies.				for each (var w:Weapon in weapons) {					if (e.hitTestPoint(localToGlobal(w.sigpt).x, localToGlobal(w.sigpt).y, true)) {						e.sicken(w.effect);					}				}								//check if the enemy has hit the user.				//use health as mass to implement simple inelastic collisions.				playerCollide(user,e);																											//check if the enemy has hit another enemy.											   										//increment index for boolean hit arrays.								n++;						}						//NOW check if either have collided with the edge of the world.			//this ensures collisions don't result in players going off the screen.			worldCollide(user);			for (n=0;n<enemies.length;n++) {			worldCollide(e);			}						//check if any weapons have hit the user's drawing.			for each (var wp:Weapon in weapons) {				if (user.hitTestPoint(localToGlobal(wp.sigpt).x, localToGlobal(wp.sigpt).y, true)) {					user.sicken(wp.effect);				}			}						//check if any upgrades have hit the user's drawing.			for each (var u:Powerup in powerups) {				if (user.hitTestPoint(localToGlobal(u.sigpt).x, localToGlobal(u.sigpt).y, true)) {					//if the user has hit a Powerup, it collects it. 					user.recv(u.thing);					//delete the Powerup.				}			}								}				//function that checks if two players have collided. 		public function playerCollide(p1:Player,p2:Player) {									//set the box to the box of the future.			p1.offsetbox.x += p1.vel[0];			p1.offsetbox.y += p1.vel[1];			p2.offsetbox.x += p2.vel[0];			p2.offsetbox.y += p2.vel[1];			var p1i:Vector.<Number>=p1.vel;			var p2i:Vector.<Number>=p2.vel;			if (p1.offsetbox.hitTestObject(p2.offsetbox)) {				trace("collision detected");			//p1 is above			if ((p1.offsetbox.y+p1.offsetbox.height >= p2.offsetbox.y-0.5)&&			   (p1.offsetbox.y+p1.offsetbox.height -p1i[1]<= p2.offsetbox.y-p2i[1]+0.5)){				trace("the p1 is above");				//p2 is on the ground				if ((p2.hitbottom||p2.ontplayer)&&(p1i[1]>0)&&(p2i[1]==0)) {					trace("p2 stuck down");					p1.vel[1]=0;					p1.offsetbox.y=p2.offsetbox.y-p1.offsetbox.height;					p1.y=p1.offsetbox.y+p1.offsetbox.height/2;					p1.ontplayer=true;				//p1 is on roof 				} else if ((p1.offsetbox.y<=0||p1.onbplayer)&&(-p2i[1]>0)&&(p1i[0]==0)) {					trace("p1 stuck up");					p2.vel[1]=0;					p2.offsetbox.y=p1.offsetbox.y+p1.offsetbox.height;					p2.y=p1.offsetbox.y+p1.offsetbox.height/2;					p2.onbplayer=true;				//in middle				} else if (p1i[1]-p2i[1]>0) {					trace("in vmiddle");					//inelastic collision					p1.vel[1]=p2.vel[1]=(p1.health*p1i[1]+p2.health*p2i[1])/											(p1.health+p2.health);					//fudged elastic collision					p1.vel[1] += cg*(p2.offsetbox.y-p1.offsetbox.height-p1.offsetbox.y);					p2.vel[1] -= cg*(p2.offsetbox.y-p1.offsetbox.height-p1.offsetbox.y);								} 			}			//p1 is below			if ((p1.offsetbox.y  <= p2.offsetbox.y+p2.offsetbox.height+0.5)&&					(p1.offsetbox.y-p1i[1] >= p2.offsetbox.y-p1i[1]+p2.offsetbox.height-0.5))			{				trace("the p1 is below");				//p1 is on ground				if ((p1.hitbottom||p1.ontplayer)&&(p2i[1]>0)&&(p1i[1]==0)) {					trace("p1 is stuck down");					p2.vel[1]=0;					p2.offsetbox.y=p1.offsetbox.y-p2.offsetbox.height;					p2.y=p2.offsetbox.y+p2.offsetbox.height/2;					p2.ontplayer=true;				//p2 is on roof				} else if ((p2.hittop||p2.onbplayer)&&(-p1i[1]>0)&&(p2i[1]==0)) {					trace("p2 is stuck up");					p1.vel[1]=0;					p1.offsetbox.y=p2.offsetbox.y+p2.offsetbox.height;					p1.y=p2.offsetbox.y+p2.offsetbox.height/2;					p1.onbplayer=true;				//in between				} else if (p2i[1]-p1i[1]>0) {					trace("in vbetween")					p1.vel[1]=p2.vel[1]=(p1.health*p1i[1]+p2.health*p2i[1])/											(p1.health+p2.health);					 //fudged elastic collision					p1.vel[1] += cg*(p2.offsetbox.y+p2.offsetbox.height-p1.offsetbox.y);					p2.vel[1] -= cg*(p2.offsetbox.y+p2.offsetbox.height-p1.offsetbox.y);				} 			}			//p1 is left			if ((p1.offsetbox.x+p1.offsetbox.width >= p2.offsetbox.x-0.5)&&			   (p1.offsetbox.x+p1.offsetbox.width -p1i[0]<= p2.offsetbox.x-p2i[0]+0.5)){				trace("p1 is left");				//if either is in contact with the ground, and the vertical velocity is zero				//and the other is moving downward, cancel this motion.				//p2 on right wall				if (((p2.offsetbox.x+p2.offsetbox.width>=p2.worldwidth)||										p2.hitrplayer)&&(p1i[0]>0)&&(p2i[0]==0)) {					trace("p2 stuck right");					p1.vel[0]=0;					p1.offsetbox.x=p2.offsetbox.x-p1.offsetbox.width;					p1.x=p1.offsetbox.x+p1.offsetbox.width/2;					p1.hitrplayer=true;				//p1 on left wall				} else if (((p1.offsetbox.x<=0)||										p1.hitlplayer)&&(-p2i[0]>0)&&(p1i[0]==0)) {					trace("p1 stuck left");					p2.vel[0]=0;					p2.offsetbox.x=p1.offsetbox.x+p1.offsetbox.width;					p2.x=p2.offsetbox.x+p1.offsetbox.width/2;					p2.hitlplayer=true;				//p2 in middle				} else if (p1i[0]-p2i[0]>0) {					trace("in hmiddle");					//inelastic collision					p1.vel[0]=p2.vel[0]=(p1.health*p1i[0]+p2.health*p2i[0])/											(p1.health+p2.health);					//fudged elastic collision					p1.vel[0] += cg*(p2.offsetbox.x-p1.offsetbox.width-p1.offsetbox.x);					p2.vel[0] -= cg*(p2.offsetbox.x-p1.offsetbox.width-p1.offsetbox.x);								} 			}			//p1 is right			trace(p1.offsetbox.x,p2.offsetbox.x+p2.offsetbox.width+0.5,				p1.offsetbox.x-p1i[0],p2.offsetbox.x-p2i[0]+p2.offsetbox.width-0.5);			if ((p1.offsetbox.x  <= p2.offsetbox.x+p2.offsetbox.width+0.5)&&					(p1.offsetbox.x-p1i[0] >= p2.offsetbox.x-p2i[0]+p2.offsetbox.width-0.5))			{				trace("the p1 is right");				//p2 is on left wall				if (((p2.offsetbox.x<=0)||(p2.hitlplayer))&&(-p1i[0]>0)&&(p2i[0]==0)) {					trace("p2 is stuck left");					p1.vel[0]=0;					p1.offsetbox.x=p2.offsetbox.x+p2.offsetbox.width;					p1.x=p1.offsetbox.x+p1.offsetbox.width/2;					p1.hitlplayer=true;				//p1 is on right wall				} else if (((p1.offsetbox.x+p1.offsetbox.width>=p1.worldwidth)||													(p1.hitrplayer))&&(p2i[0]>0)&&(p1i[0]==0)) {					trace("p2 is stuck right");					p2.vel[0]=0;					p2.offsetbox.x=p1.offsetbox.x-p2.offsetbox.width;					p2.x=p1.offsetbox.x+p1.offsetbox.width/2;					p2.hitrplayer=true;				//in middle				} else if (p2i[0]-p1i[0]>0) {					trace("in hmiddle");					p1.vel[0]=p2.vel[0]=(p1.health*p1.vel[0]+p2.health*p2.vel[0])/											  (p1.health+p2.health);					 //fudged elastic collision					p1.vel[0] += cg*(p2.offsetbox.x+p2.offsetbox.width-p1.offsetbox.x);					p2.vel[0] -= cg*(p2.offsetbox.x+p2.offsetbox.width-p1.offsetbox.x);				}			}			} 								//reset offsetbox			p1.offsetbox.x -= p1.vel[0];			p1.offsetbox.y -= p1.vel[1];			p2.offsetbox.x -= p2.vel[0];			p2.offsetbox.y -= p2.vel[1];		}				//function that tests for collisions of players with the world.		public function worldCollide(r:Player) {			var top:Number = r.offsetbox.y;			var bottom:Number = r.offsetbox.y+r.offsetbox.height;			var left:Number =r.offsetbox.x;			var right:Number =r.offsetbox.x+r.offsetbox.width ;									if (bottom+r.ground<r.worldheight-0.5*gravity) {				r.hitbottom=false;			}			if ((left<=0)&&(r.vel[0]<0)) {				r.vel[0]=0;			} else if ((right>= r.worldwidth)&&(r.vel[0]>0)) {				r.vel[0]=0;			}			if ((top<=0)&&(r.vel[1]<0)) {				r.vel[1]*=-1;			} else if ((bottom+r.ground >= r.worldheight)&&(r.vel[1]>0)) {				r.gotoAndPlay(1);				r.setAttack();				r.hitbottom=true;				//ensure that the player stops moving left/right when he hits the ground, 				//if he has stopped running.				r.vel[0] = ((!r.fcalled[0])&&(!r.fcalled[1]))?0:r.vel[0];				r.vel[1]=0;				r.y=r.worldheight-r.height/2;				r.resetBox();								trace("bottom ",r,r.vel);			}		}				//returns the magnitude.		public function mag(v:Vector.<Number>):Number {			return Math.sqrt(Math.pow(v[0],2)+Math.pow(v[1],2));		}				public function mag2(v:Point):Number {			return Math.sqrt(Math.pow(v.x,2)+Math.pow(v.y,2));		}				//returns a vector from one point to another.		public function vectorFrom(x1:Number,y1:Number,x2:Number,y2:Number):Point {			return new Point(x2-x1,y2-y1);		}		//returns the angle of the vector returned by vectorFrom		public function angleTo(x1:Number,y1:Number,x2:Number,y2:Number):Number {			return (vectorFrom(x1,y1,x2,y2).x>0)?Math.atan(vectorFrom(x1,y1,x2,y2).y/vectorFrom(x1,y1,x2,y2).x)												:Math.PI+Math.atan(vectorFrom(x1,y1,x2,y2).y/vectorFrom(x1,y1,x2,y2).x);		}				//function that pauses the game.		public function pauseGame(e:KeyboardEvent) {					//set the frame rate to zero.			//(p)			if (e.keyCode == 80) stage.frameRate =(stage.frameRate < 1)?60:0;			//trace(user.head.x);						}				//timeline functions for the menu		function home(e:MouseEvent) {			gotoAndStop(1);		}		function playGame(e:MouseEvent) {			gotoAndStop(3);		}		function help(e:MouseEvent) {			gotoAndStop(2);		}			}}